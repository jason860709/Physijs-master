<html><head>
<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Tangerine">
<style>
#info {
 font-family: 'Tangerine', serif;
  position: absolute;
  top: 1%;
  width: 100%;
  padding: 10px;
  text-align: center;
  font-size: 48px;
  color: #232321
  opacity:0;
}
#Score {
  position: absolute;
  padding: 25px;
  text-align: center;
  color: #ffff00;
  left:70%;
  top: -3%;
}
#remainingTime {
  position: absolute;
  padding: 25px;
  text-align: center;
  color: #ffff00;
  left:70%;
}
body {
  overflow: hidden;
}
#blocker {
	position: absolute;
	width: 100%;
	height: 100%;
	background-color: rgba(0, 0, 0, 0.3);
}
		
#instructions {
	width: 100%;
	height: 65%;
	font-size: 30px;
	font-family: 'Courier New';
	display: -webkit-box;
	display: -moz-box;
	-webkit-box-orient: horizontal;
	-moz-box-orient: horizontal;
	-webkit-box-pack: center;
	-moz-box-pack: center;
	-webkit-box-align: center;
	-moz-box-align: center;
	color: #ffffff;
	text-align: center;
	cursor: pointer;
	opacity:1.0;
}

#luckk {
	width: 100%;
	height: 100%;
	
	font-size: 30px;
	font-family: 'Courier New';r;
	color: #ffffff;
	opacity:1.0;
}

div {margin:5px}
</style>
</head>

<body> 
<h1 id="info">Rube’s Lab
<br>
	<div>
	<strong>rotate: shift + click</strong>
	</div>

</h1>

<div id ="remainingTime" >
<h2 style ="width:300px">Time : 
<div id="counter" style="float:right">0</div>
</h2>
</div>

<div id="Score" >
<h2 style ="width:300px">Score : 
<div id="score1" style="float:right">150</div>
</h2>
</div>
<div id= "broadcast" style="width:42%;height:45%;position:absolute;left: 30%;top: 25%;visibility: hidden;">
	<h1 style="font-family:Microsoft JhengHei;color:red;font-size: 600%;text-align: center;margin-top: 0px;margin-bottom: 0px;padding-top: 0px;">ＷＩＮ！！</h1>
	
	<div>
	<h2 style="font-family:Microsoft JhengHei;top: 35%;position: absolute;left: 5%;font-size: 300%;">Score :</h2>
	<div id="numScore" style="position:absolute;top: 40%;left: 50%;font-size: 500%;">90</div>
	</div>
	
	<div>
	<h2 style="font-family:Microsoft JhengHei;top: 60%;position: absolute;left: 5%;font-size: 300%;">Time  :</h2>
	<div id="numTime" style="position:absolute;top: 65%;left: 50%;font-size: 500%;">50</div>
	</div>
</div>

<audio id="soundtrack" autoplay="" loop="" style="display:none">
	<source src="sound/BGM.mp3" type="audio/mp3">
</audio>
<audio id="clear" style="display:none">
	<source src="sound/Clearance.mp3" type="audio/mp3">
</audio>
<audio id="click" style="display:none">
	<source src="sound/click.mp3" type="audio/mp3">
</audio>
<audio id="crash" style="display:none">
	<source src="sound/punch1.mp3" type="audio/mp3">
</audio>
<audio id="over" style="display:none">
	<source src="sound/over.mp3" type="audio/mp3">
</audio>
<audio id="springcrash" style="display:none">
	<source src="sound/Springcash.mp3" type="audio/mp3">
</audio>
<div id="blocker">

	<div id="instructions">
      <strong>
	  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start/stop the ball</p>
	  <p>Reset the bal&nbsp;</p>
	  <p>Reset all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
	  <p>prompt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
	  <p>turn/close bgm</p>
	  Click ? to unlock or look the help</strong>
	
	</div>	
    <div id="luckk" style="position:absolute;left:0%;top: 9%;">
      <strong> Click</strong>
	
	</div>

</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<script src="Ball.js"></script>
<script src="Rect.js"></script>
<script src="ggrect.js"></script>
<script src="Ballb.js"></script>
<script>
var Allscore = 150;
var CountSC=0;
var seconds = 0
var countC = true;
var temp = 0;
var ans = 0;
var countlevel=0;
function timeCount (){
	setTimeout(function () {
		//console.log("1  "+seconds);
        if (countC == true) {
            seconds++;
			timeCount ();
			$('#counter').html(seconds);
			scoreDown()
        }
		else{
			console.log("Score.time = "+seconds);
			CountSC = seconds;
		}
    }, 1000);
}
			
function MissionUP(){
	$('#score1').html(Allscore+" + 20");
	countC = false;	
	Allscore = Allscore + 20;
}
function TimeRE(){
	if(countC == false){
		countC = true;
	}
	seconds = 0;
	Allscore = 150;
	
}
function scoreDown(){
	if(seconds < 70){
		Allscore = Allscore-1;
		$('#score1').html(Allscore);
	}
	if(seconds > 70 && Allscore > 0){
		temp=temp+1;
		if(temp ==10){
			Allscore = Allscore-1
			$('#score1').html(Allscore);
			temp = 0;
		}
	}
}
function thankPlane(){
	let loader = new THREE.TextureLoader()
	loader.crossOrigin = '';
	var finishplane =  new THREE.Mesh(new THREE.PlaneGeometry(500, 300), new THREE.MeshBasicMaterial({
    transparent: true,
    //opacity: 0.5,
	map: loader.load("strts/finish.png"),
    //visible: true
  }));
	finishplane.number = 0;
	
	console.log("123kk")
	
	finishplane.position.z = 100;
	scene.add(finishplane)
	pickables.push(finishplane)
}
///////////////////////////////////////
function clickplay(){
	click.pause();
    click.currentTime = 0;
	click.play();
}
function springPlay(){
	springcrash.pause();
    springcrash.currentTime = 0;
	springcrash.play();
}
function crashPlay(){
    crash.pause();
    crash.currentTime = 0;
	crash.play();
}
function checkIntersect (rect, ball) {
  // move coordinate origin to circle.center
	let point = rect.center.clone().sub(ball.center)
  let rectCenter = new THREE.Vector3(point.dot(rect.axes[0]), point.dot(rect.axes[1]), 0);
  
  rmax = [ rectCenter.x + rect.sizes[0]/2, rectCenter.y + rect.sizes[1]/2 ]
  rmin = [ rectCenter.x - rect.sizes[0]/2, rectCenter.y - rect.sizes[1]/2 ]
  //console.log()
 
  let rad = ball.rad;
  //console.log (rect.sizes);
  if (rmax[0] < 0) {  // R to left of center
  	if (rmax[1] < 0)  // R in lower left corner
    	return (rmax[0]*rmax[0] + rmax[1]*rmax[1] < rad*rad ) ? /*numtest(2,0)*/ 44: -1;
    else if (rmin[1] > 0)  // R in upper left corner
    	return (rmax[0]*rmax[0] + rmin[1]*rmin[1] < rad*rad ) ? /*numtest(0,3)*/ 11: -1;
    else // R to the west of circle
    	return ( Math.abs(rmax[0]) < rad ) ? 0 : -1;
  } else if (rmin[0] > 0) {  // R to right of center
  	if (rmax[1] < 0)  // R in lower right corner
    	return (rmin[0]*rmin[0] + rmax[1]*rmax[1] < rad*rad) ?/* numtest(1,2) */33: -1;
    else if (rmin[1] > 0) // R in upper right corner
    	return (rmin[0]*rmin[0] + rmin[1]*rmin[1] < rad*rad) ?/* numtest(3,1) */22: -1;
    else  // R to the east of circle
    	return ( Math.abs(rmin[0]) < rad) ? 1 : -1;
  } else {
  	if (rmax[1] < 0)  // R: south of circle
    	return ( Math.abs(rmax[1]) < rad ) ? 2 : -1;
    else if (rmin[1] > 0)  // R: north of circle
    	return ( rmin[1] < rad ) ? 3 : -1
    else
    	return 5;  
  }
}
function numtest(num1,num2) {
   var arr = [num1,num2];
	var ran = Math.floor(Math.random() * 2);
	return arr[ran]; 
}
function smallRE(num) {
	for(let i=0;i<balls.length;i++){
		balls[i].delet()
	}
	for(let x = 0; x < objects.length ; x++){
		if(objects[x].type === 'ball'){
			objects[x] = [];
		}
	}
	
	balls = [];
	if(num == 0){
	level0ballmake()
	}
	if(num==1){
	level1ballmake();
	}
	if(num==2){
	level2ballmake();
	}
	if(num==3){
	}
	 
}
function bigRE(num) {
	while(scene.children.length > 0){ 
    scene.remove(scene.children[0]); 
}
	
	balls = [];
	objects = [];
	rect = [];
	cube = [];
	pickables = [];
	for(var g = 0 ; g<angle.length;g++){
	angle[g] = 0;
	}
	if(num==0){
	level0make();
	level0ballmake();
	}
	if(num==1){
	level1make();
	level1ballmake();
	}
	if(num==2){
	level2make();
	level2ballmake();
	}
	if(num==3){
	}
	
	makecilck();
	
	TimeRE();
}
function collision () {
	for (let i = 0; i < objects.length; i++) {
		for (let j = i+1; j < objects.length; j++) {
			intersect (objects[i], objects[j]);
		}
	}
}
function intersect (obj1, obj2) {
	let hit;
	
	if (obj1.type === 'ball' && obj2.type === 'rect') {
		if((hit = checkIntersect(obj2, obj1))>=0){
			console.log(hit)
			ballrectIntersect (obj2, obj1,hit)
			}
	}
	
	else if (obj1.type === 'rect' && obj2.type === 'ball') {
		if((hit = checkIntersect(obj1, obj2))>=0){
			//console.log(hit)
			ballrectIntersect (obj1, obj2,hit)
			}
	}
	
	if (obj1.type === 'ball' && obj2.type === 'finish') {
		if((hit = checkIntersect(obj2, obj1))>=0){
			console.log(hit)
			//ballrectIntersect (obj2, obj1,hit)
			//console.log(score);
			//
			start = !start;
			obj1.moveTo(100,0)
			thisfinish();
			}
	}
	
	else if (obj1.type === 'finish' && obj2.type === 'ball') {
		if((hit = checkIntersect(obj1, obj2))>=0){
			console.log(hit)
				//ballrectIntersect (obj1, obj2,hit)
			//console.log(score);
			//
			start = !start;
			obj2.moveTo(100,0)
			thisfinish();
			}
	}
	
	else if (obj1.type === 'ball' && obj2.type === 'ball') 
		ballBallIntersect (obj1, obj2,hit)
	}
	
function ballrectIntersect (rect, ball, hit) {
	//let hit;
	//if((hit = checkIntersect(rect, ball))>=0){
	if(rect.resCoeff != 0.9){
		springPlay()
	}
	else{
		crashPlay()
	}
	if(hit === 0){
		let point = new THREE.Vector3();
		//rect.obj.updateMatrix()
    var b = rect.obj.localToWorld(new THREE.Vector3(0,0,0))
    let a = rect.obj.localToWorld(new THREE.Vector3(1,0,0))
	//console.log( a)
    a.sub(b).normalize
    //console.log(a)
    rect.normal.copy(a)
    
		point.copy (ball.pos).sub (rect.pc);
		//console.log(rect.normal)
		if (point.dot(rect.normal) <rect.sizes[0]/2 + ball.rad) {  // close enough
			let vn;  // normal velocity component
    
			if ((vn = ball.vel.dot (rect.normal)) < -3.0) {  // run towards plane
				console.log ('vn: '+vn)
				ball.vel.sub (ball.vel.clone().projectOnVector 	(rect.normal).multiplyScalar (1+rect.resCoeff))
			} else if (vn <= 0) {  // contact
			ball.force.projectOnPlane (rect.normal);  // force correction
		  //console.log ('force: ' + ball.force.y)
			ball.vel.projectOnPlane (rect.normal)   // vel correction
		  //console.log ('vel: ' + ball.vel.y)
			ball.pos.copy (point.projectOnPlane (rect.normal).add(rect.pc).add(rect.normal.clone().multiplyScalar(ball.rad+rect.sizes[0]/2)))   // position correction
			
			}
		}
	}
	if(hit === 1){
		let point = new THREE.Vector3();
    
    var b = rect.obj.localToWorld(new THREE.Vector3(0,0,0))
    let a = rect.obj.localToWorld(new THREE.Vector3(-1,0,0))
	//console.log(a)
    a.sub(b).normalize
    //console.log(a)
    rect.normal.copy(a)
    
		point.copy (ball.pos).sub (rect.pc);
		if (point.dot(rect.normal) <rect.sizes[0]/2 + ball.rad) {  // close enough
			let vn;  // normal velocity component
			
			if ((vn = ball.vel.dot (rect.normal)) < -3.0) {  // run towards plane
				console.log ('vn: '+vn)
				ball.vel.sub (ball.vel.clone().projectOnVector 	(rect.normal).multiplyScalar (1+rect.resCoeff))
			} else if (vn <= 0) {  // contact
			ball.force.projectOnPlane (rect.normal);  // force correction
		  //console.log ('force: ' + ball.force.y)
			ball.vel.projectOnPlane (rect.normal)   // vel correction
		  //console.log ('vel: ' + ball.vel.y)
			ball.pos.copy (point.projectOnPlane (rect.normal).add(rect.pc).add(rect.normal.clone().multiplyScalar(ball.rad+rect.sizes[0]/2)))   // position correction
			}
		}
	}
	if(hit === 2){
		let point = new THREE.Vector3();
		
		 var b = rect.obj.localToWorld(new THREE.Vector3(0,0,0))
		let a = rect.obj.localToWorld(new THREE.Vector3(0,1,0))
		//console.log(a)
		a.sub(b).normalize
		rect.normal.copy(a)
		point.copy (ball.pos).sub (rect.pc);
		if (point.dot(rect.normal) <rect.sizes[1]/2 + ball.rad) {  // close enough
			let vn;  // normal velocity component
			
			if ((vn = ball.vel.dot (rect.normal)) < -3.0) {  // run towards plane
				console.log ('vn: '+vn)
				ball.vel.sub (ball.vel.clone().projectOnVector 	(rect.normal).multiplyScalar (1+rect.resCoeff))
			} else if (vn <= 0) {  // contact
			ball.force.projectOnPlane (rect.normal);  // force correction
		  //console.log ('force: ' + ball.force.y)
			ball.vel.projectOnPlane (rect.normal)   // vel correction
		  //console.log ('vel: ' + ball.vel.y)
			ball.pos.copy (point.projectOnPlane (rect.normal).add(rect.pc).add(rect.normal.clone().multiplyScalar(ball.rad+rect.sizes[1]/2)))   // position correction
			}
		}
	}
	if(hit === 3){
		let point = new THREE.Vector3();
    
    var b = rect.obj.localToWorld(new THREE.Vector3(0,0,0))
    let a = rect.obj.localToWorld(new THREE.Vector3(0,-1,0))
    a.sub(b).normalize
    rect.normal.copy(a)
		point.copy (ball.pos).sub (rect.pc);
		
		if (point.dot(rect.normal) <rect.sizes[1]/2 + ball.rad) {  // close enough
			let vn;  // normal velocity component
			
			if ((vn = ball.vel.dot (rect.normal)) < -3.0) {  // run towards plane
				console.log ('vn: '+vn)
				ball.vel.sub (ball.vel.clone().projectOnVector 	(rect.normal).multiplyScalar (1+rect.resCoeff))
			} else if (vn <= 0) {  // contact
			ball.force.projectOnPlane (rect.normal);  // force correction
		  //console.log ('force: ' + ball.force.y)
			ball.vel.projectOnPlane (rect.normal)   // vel correction
		  //console.log ('vel: ' + ball.vel.y)
			ball.pos.copy (point.projectOnPlane (rect.normal).add(rect.pc).add(rect.normal.clone().multiplyScalar(ball.rad+rect.sizes[1]/2)))   // position correction
			}
		}
	}
	
	if(hit === 11){
	
			var b = rect.obj.localToWorld(new THREE.Vector3(rect.sizes[0]/2,0,0))
			let a = rect.obj.localToWorld(new THREE.Vector3(0,-rect.sizes[1]/2,0))
			a.add(b)
			a.sub(rect.pc)
			var ball1pc = new THREE.Vector3();
			ball1pc.copy(a);
			console.log(ball1pc);
			var b1rad =ball.rad;
			console.log('ba1rad: ' + b1rad);
			
			let centerDist = ball1pc.distanceTo (ball.pos)
			if (centerDist < ball.rad) {
			console.log ('ball-ball hit');
			let p1 = ball1pc;
			let p2 = ball.pos;
			let n = p1.clone().sub(p2).normalize();
			//console.log(ball.vel)
			let v12 = ball.vel.clone().sub((ball.vel).add(ball.vel));
			console.log(v12)
			
			//b1.vel.sub (n.clone().multiplyScalar (v12.dot(n)*2*b2.mass/(b1.mass+b2.mass) ))
			ball.vel.add (n.clone().multiplyScalar (v12.dot(n)*2*1.2 ))
			
			//console.log ('after:'+b1.vel.x)
				// position correction
			let vv = ball.pos.clone().sub(ball1pc);
			let overlap = (ball.rad) - vv.length();
			vv.normalize();
			//b1.pos.add ( vv.clone().multiplyScalar  (-overlap/2))
			//ball.pos.add ( vv.clone().multiplyScalar  (overlap/2))
			
			}
		}
		
	if(hit === 22){
	
			var b = rect.obj.localToWorld(new THREE.Vector3(-rect.sizes[0]/2,0,0))
			let a = rect.obj.localToWorld(new THREE.Vector3(0,-rect.sizes[1]/2,0))
			a.add(b)
			a.sub(rect.pc)
			var ball1pc = new THREE.Vector3();
			ball1pc.copy(a);
			console.log(ball1pc);
			var b1rad =ball.rad;
			console.log('ba1rad: ' + b1rad);
			
			let centerDist = ball1pc.distanceTo (ball.pos)
			if (centerDist < ball.rad) {
			console.log ('ball-ball hit');
			let p1 = ball1pc;
			let p2 = ball.pos;
			let n = p1.clone().sub(p2).normalize();
			//console.log(ball.vel)
			let v12 = ball.vel.clone().sub((ball.vel).add(ball.vel));
			console.log(v12)
			
			//b1.vel.sub (n.clone().multiplyScalar (v12.dot(n)*2*b2.mass/(b1.mass+b2.mass) ))
			ball.vel.add (n.clone().multiplyScalar (v12.dot(n)*2*1.2 ))
			
			//console.log ('after:'+b1.vel.x)
				// position correction
			let vv = ball.pos.clone().sub(ball1pc);
			let overlap = (ball.rad) - vv.length();
			vv.normalize();
			//b1.pos.add ( vv.clone().multiplyScalar  (-overlap/2))
			//ball.pos.add ( vv.clone().multiplyScalar  (overlap/2))
			
			}
		}
	
	if(hit === 33){
	
			var b = rect.obj.localToWorld(new THREE.Vector3(-rect.sizes[0]/2,0,0))
			let a = rect.obj.localToWorld(new THREE.Vector3(0,rect.sizes[1]/2,0))
			a.add(b)
			a.sub(rect.pc)
			var ball1pc = new THREE.Vector3();
			ball1pc.copy(a);
			console.log(ball1pc);
			var b1rad =ball.rad;
			console.log('ba1rad: ' + b1rad);
			
			let centerDist = ball1pc.distanceTo (ball.pos)
			if (centerDist < ball.rad) {
			console.log ('ball-ball hit');
			let p1 = ball1pc;
			let p2 = ball.pos;
			let n = p1.clone().sub(p2).normalize();
			//console.log(ball.vel)
			let v12 = ball.vel.clone().sub((ball.vel).add(ball.vel));
			console.log(v12)
			
			//b1.vel.sub (n.clone().multiplyScalar (v12.dot(n)*2*b2.mass/(b1.mass+b2.mass) ))
			ball.vel.add (n.clone().multiplyScalar (v12.dot(n)*2*1.2 ))
			
			//console.log ('after:'+b1.vel.x)
				// position correction
			let vv = ball.pos.clone().sub(ball1pc);
			let overlap = (ball.rad) - vv.length();
			vv.normalize();
			//b1.pos.add ( vv.clone().multiplyScalar  (-overlap/2))
			//ball.pos.add ( vv.clone().multiplyScalar  (overlap/2))
			
			}
		}
		
	if(hit === 44){
	
			var b = rect.obj.localToWorld(new THREE.Vector3(rect.sizes[0]/2,0,0))
			let a = rect.obj.localToWorld(new THREE.Vector3(0,rect.sizes[1]/2,0))
			a.add(b)
			a.sub(rect.pc)
			var ball1pc = new THREE.Vector3();
			ball1pc.copy(a);
			console.log(ball1pc);
			var b1rad =ball.rad;
			console.log('ba1rad: ' + b1rad);
			
			let centerDist = ball1pc.distanceTo (ball.pos)
			if (centerDist < ball.rad) {
			console.log ('ball-ball hit');
			let p1 = ball1pc;
			let p2 = ball.pos;
			let n = p1.clone().sub(p2).normalize();
			console.log(ball.vel)
			let v12 = ball.vel.clone().sub((ball.vel).add(ball.vel));
			console.log(v12)
			
			//b1.vel.sub (n.clone().multiplyScalar (v12.dot(n)*2*b2.mass/(b1.mass+b2.mass) ))
			ball.vel.add (n.clone().multiplyScalar (v12.dot(n)*2*1.2 ))
			//console.log ('after:'+b1.vel.x)
					// position correction
			let vv = ball.pos.clone().sub(ball1pc);
			let overlap = (b1rad) - vv.length();
			vv.normalize();
			//b1.pos.add ( vv.clone().multiplyScalar  (-overlap/2))
			//ball.pos.add ( vv.clone().multiplyScalar  (overlap/2))
			}
		}
	}
function ballBallIntersect (b1, b2,hit) {	
	let centerDist = b1.pos.distanceTo (b2.pos)
  if (centerDist < b1.rad + b2.rad) {
	crashPlay();
  	console.log ('ball-ball hit')
	let p1 = b1.pos;
    let p2 = b2.pos;
    let n = p1.clone().sub(p2).normalize();
	
    let v12 = b1.vel.clone().sub(b2.vel)
    b1.vel.sub (n.clone().multiplyScalar (v12.dot(n)*2*b2.mass/(b1.mass+b2.mass) ))
    b2.vel.add (n.clone().multiplyScalar (v12.dot(n)*2*b1.mass/(b1.mass+b2.mass) ))
    //console.log ('after:'+b1.vel.x)
		// position correction
    let vv = b2.pos.clone().sub(b1.pos);
    let overlap = (b2.rad+b1.rad) - vv.length();
    vv.normalize();
    b1.pos.add ( vv.clone().multiplyScalar  (-overlap/2))
    b2.pos.add ( vv.clone().multiplyScalar  (overlap/2))
  }
}
var bigcube = new THREE.Object3D();
function thisfinish(){
	
	MissionUP();
	//var bigcube = new THREE.Object3D();
	clear.play();
	let loader = new THREE.TextureLoader()
	loader.crossOrigin = '';
	
	var finishcube =  new THREE.Mesh(new THREE.PlaneGeometry(450, 300), new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0
     }));
	finishcube.number = 0;//過關換圖
	////
	 document.getElementById( "broadcast" ).style.visibility = "visible";
	 $('#numScore').html(Allscore);
	 $('#numTime').html(seconds+" s ");
	////
	
	var finishplane =  new THREE.Mesh(new THREE.PlaneGeometry(500, 300), new THREE.MeshBasicMaterial({
    transparent: true,
    //opacity: 0.5,
	map: loader.load("strts/score1.png"),
    //visible: true
  }));
	finishplane.number = 0;
	
///////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	
	
///////////////////////////////////////////////////////////////////////////////////////////////////////
	var click1 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({
	transparent: true,
	map: loader.load("strts/restart.png")
	}));
	click1.number = -4 ;
	click1.position.set(-40,-60,0);
	var click2 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({
	transparent: true,
	map: loader.load("strts/start.png")
	}));
	click2.number = -5;
	click2.position.set(40,-60,0);
  
	bigcube.add(click1);
	bigcube.add(click2);
	bigcube.add(finishplane);
	bigcube.add(finishcube);
	
	pickables.push(bigcube)
	/*pickables.push(click2)
	pickables.push(finishplane)
	pickables.push(finishcube)
	*/
	bigcube.position.z = 100
	scene.add(bigcube);
}
function refinish(num){
	while(scene.children.length > 0){ 
    scene.remove(scene.children[0]); 
}
	balls = [];
	objects = [];
	rect = [];
	cube = [];
	pickables = [];
	bigcube = new THREE.Object3D();
	//console.log(bigcube)
	for(var g = 0 ; g<angle.length;g++){
	angle[g] = 0;
	}
	if(num==0){
	level0make();
	level0ballmake()
	}
	if(num==1){
	level1make();
	level1ballmake();
	}
	if(num==2){
	level2make();
	level2ballmake();
	}
	if(num==3){
	}
	
	makecilck();
	
	
	TimeRE();
	timeCount ();
	document.getElementById( "broadcast" ).style.visibility = "hidden";
}
function buildlevel(num){
	while(scene.children.length > 0){ 
    scene.remove(scene.children[0]); 
}
	balls = [];
	objects = [];
	rect = [];
	cube = [];
	pickables = [];
	bigcube = new THREE.Object3D();
	if(num == 0){
	
	}
	if(num == 1){
		level1make();
		level1ballmake();
		/////////////////////
		makecilck()
		TimeRE();
		timeCount ();
		document.getElementById( "broadcast" ).style.visibility = "hidden";
	}
	
	if(num == 2){
		level2make();
		level2ballmake();
		/////////////////////////////
		makecilck()
		TimeRE();
		timeCount ();
		document.getElementById( "broadcast" ).style.visibility = "hidden";
	}
	
	if(num == 3){
		document.getElementById( "broadcast" ).style.visibility = "hidden";
		thankPlane();
	}
	if(num==4){
	}
	if(num==5){
	}
}
var start = false;
var addf = false;
var isShiftDown = false
var bgms = false;//背景音樂開關
var lock = false;//解說屏幕開關
var camera, scene, renderer;
var stats;
var objects, balls;
var ball;
var angle = [0];
////////////////////////////
var brick;
var mouse = new THREE.Vector2();
var raycaster , raycaster1;
var pickables = [];
var cube = [];
var movetest;
var keyboard = new KeyboardState();
var texture;
var levelnum = 0;
var level0 = new THREE.Object3D();
init();
animate();
function init() {
	
	/////////sound
  var soundTrack = document.getElementById ('soundtrack');
  var clear = document.getElementById ('clear');
  var click = document.getElementById ('click');
  var crash = document.getElementById ('crash');
  var over = document.getElementById ('over');
  var springcrash = document.getElementById ('springcrash');
  crash.volume = 0.09;
  soundtrack.volume = 0.03;
  click.volume = 0.15;
  springcrash.volume = 0.09
  clear.volume = 0.09;
  soundtrack.pause();
  /////////////////////////////////////////////////////////////////////
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  
  document.body.appendChild(renderer.domElement);
  
  whRatio = window.innerWidth/window.innerHeight
	halfH = 140;
  halfW = halfH*whRatio
  // STATS
	/*stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.zIndex = 100;
	document.body.appendChild( stats.domElement );	
  */
  
  let loader = new THREE.TextureLoader()
	loader.crossOrigin = '';
   scene = new THREE.Scene();
   scene.background = loader.load("https://i.imgur.com/PaWt7bj.jpg")
     camera = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, -10, 100);
   camera.position.z = 100;
	let grid = new THREE.GridHelper (200,20, 'red','white');
	//scene.add (grid)
    grid.rotation.x = Math.PI/2
    
	window.addEventListener('resize', onWindowResize, false);
////////////////////////////////////////////////////
	level0make();
	makecilck();
	level0ballmake()
////////////////////////////////////////////////////////////
	
////////////////////////////////////////////////////////////
	raycaster = new THREE.Raycaster();
	document.addEventListener('mousemove', onDocumentMouseMove, false);
	document.addEventListener('mousedown', onDocumentMouseDown, false);
	document.addEventListener( 'keydown', onDocumentKeyDown, false );
	document.addEventListener( 'keyup', onDocumentKeyUp, false );
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
	interval = timeCount();
}
function makecilck() {
	let loader = new THREE.TextureLoader()
	loader.crossOrigin = '';
	
	texture = loader.load('strts/start.png');
	
	cilck1 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({
		transparent: true,
		map: texture,
		needsUpdate : true
	}));
	cilck1.number = -1;
	scene.add(cilck1);
	pickables.push(cilck1);
	cilck1.position.set(120,-90,0);
	var cilck2 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({
		transparent: true,
		map: loader.load("strts/restart.png")
	}));
	cilck2.number = -2;
	scene.add(cilck2);
	pickables.push(cilck2);
	cilck2.position.set(155,-90,0);
	var cilck3 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({
		transparent: true,
		map: loader.load("strts/stop.png")
	}));
	cilck3.number = -3;
	scene.add(cilck3);
	pickables.push(cilck3);
	cilck3.position.set(190,-90,0);
	console.log(cilck1)
	
	var cilck4 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({//問號功能
		transparent: true,
		map: loader.load("https://i.imgur.com/3cSKQsQ.png")
	}));
	cilck4.number = -6;
	scene.add(cilck4);
	pickables.push(cilck4);
	cilck4.position.set(-263,125,0);
	
	var cilck5 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({//驚嘆號題示
		transparent: true,
		map: loader.load("https://i.imgur.com/cMsbWvr.png")
	}));
	cilck5.number = -7;
	scene.add(cilck5);
	pickables.push(cilck5);
	cilck5.position.set(260,-90,0);
	/////////////
	if(countlevel === 1 ){
	brickfa11 = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.3, transparent: true }));
	brickfa11.name = "mybrickf";
	brickfa11.position.set (500,500,10);
	scene.add(brickfa11);
	
	brickfa12 = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0x42e54d, opacity: 0.3, transparent: true }));
	brickfa12.name = "mybrickf";
	brickfa12.position.set (500,500,10);
	scene.add(brickfa12);
	}
	
	if(countlevel === 2 ){
	brickfa21 = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.3, transparent: true }));
	brickfa21.name = "mybrickf";
	brickfa21.position.set (500,500,10);
	scene.add(brickfa21);
	
	brickfa22 = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0x42e54d, opacity: 0.3, transparent: true }));
	brickfa22.name = "mybrickf";
	brickfa22.position.set (500,500,10);
	scene.add(brickfa22);
	
	brickfa23 = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0x42e54d, opacity: 0.3, transparent: true }));
	brickfa23.name = "mybrickf";
	brickfa23.position.set (500,500,10);
	scene.add(brickfa23);
	
	brickfa24 = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.3, transparent: true }));
	brickfa24.name = "mybrickf";
	brickfa24.position.set (500,500,10);
	scene.add(brickfa24);
	}
	////////////////////////////
	
    cilck6 = new THREE.Mesh(new THREE.CircleGeometry(13,32),new THREE.MeshBasicMaterial({//背景音量
		transparent: true,
		map: loader.load("https://i.imgur.com/OaKK32e.jpg")
	}));
	cilck6.number = -8;
	scene.add(cilck6);
	pickables.push(cilck6);
	cilck6.position.set(225,-90,0);
	if(bgms){//換關BUG
		cilck6.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/P4CP2NK.jpg");
		soundtrack.play();
	}
	else {
		cilck6.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/OaKK32e.jpg");
		soundtrack.pause();
	}		
	
	//////////////解說圖
	lo1 = new THREE.Mesh(new THREE.CircleGeometry(7,32),new THREE.MeshBasicMaterial({
		transparent: true,
		map: texture,
		needsUpdate : true
	}));			
	scene.add(lo1);
	lo1.position.set(-50,89,0);
    if(lock == true ){//過關會有BUG 所以多設一次 
		lo1.position.set(500,500,0);		
	}
	lo2 = new THREE.Mesh(new THREE.CircleGeometry(7,32),new THREE.MeshBasicMaterial({
		transparent: true,
		map: loader.load("strts/restart.png")
	}));
	scene.add(lo2);
	lo2.position.set(-50,69.5,0);
	if(lock == true ){//過關會有BUG 所以多設一次 		
		lo2.position.set(500,500,0);
	}
	
	lo3 = new THREE.Mesh(new THREE.CircleGeometry(7,32),new THREE.MeshBasicMaterial({
		transparent: true,
		map: loader.load("strts/stop.png")
	}));
	scene.add(lo3);
	lo3.position.set(-50,50.5,0);
	if(lock == true ){//過關會有BUG 所以多設一次 
		lo3.position.set(500,500,0);
	}
	
	lo4 = new THREE.Mesh(new THREE.CircleGeometry(7,32),new THREE.MeshBasicMaterial({//驚嘆號題示
		transparent: true,
		map: loader.load("https://i.imgur.com/cMsbWvr.png")
	}));
	scene.add(lo4);
	lo4.position.set(-50,31.5,0);
	if(lock == true ){//過關會有BUG 所以多設一次 
		lo4.position.set(500,500,0);
	}
	
    lo5 = new THREE.Mesh(new THREE.CircleGeometry(7,32),new THREE.MeshBasicMaterial({//背景音量
		transparent: true,
		map: loader.load("https://i.imgur.com/OaKK32e.jpg")
	}));
	scene.add(lo5);
	lo5.position.set(-50,13.5,0);
	if(lock == true ){//過關會有BUG 所以多設一次 
		lo5.position.set(500,500,0);
	}
	///////////////
}
function level0make(){
	var rect = new Rect(new THREE.Vector3(15,22,0), [45,10]);
    rect.moveTo (55,-10)
	var rect1 = new Rect(new THREE.Vector3(15,22,0), [15,10]);
	rect1.moveTo (-20, 42)
	rect1.rotateTo (-Math.PI/4)
	var rect2 = new Rect(new THREE.Vector3(15,22,0), [75,10]);
	rect2.moveTo (-50, -10)
	
	objects = [rect,rect1,rect2]
	
	var ccrect = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","1");
	ccrect.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/PxBLi7K.jpg");
	ccrect.moveTo (-135,20)
	objects.push(ccrect)
	cube.push(ccrect)
	
	var finishss = new ggrect(new THREE.Vector3(15,22,0), [10,7.5]);
	finishss.moveTo (60,-1.5)
	objects.push(finishss)
	
	pickables = [finishss.obj,ccrect.obj,rect.obj,rect1.obj,rect2.obj];
	
	let brickf = new THREE.Mesh (new THREE.BoxGeometry(15,10,0), new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.3, transparent: true }));
	brickf.name = "mybrickf";
	brickf.position.set (10,-10,10);
	scene.add(brickf);
	
	for(let y = 0 ; y < cube.length;y++){
		angle[y] = Math.PI/6;
	}
    ///////////
	////////
}
function level0ballmake(){
	var ball0 = new Ball(new THREE.Vector3(),5);
    ball0.moveTo (-15,52)
	
	balls = [ball0];
	console.log(balls)
	
	objects.push(ball0)
}
function level1make(){
	countlevel=1;
	ans=0;
	var rect = new Rect(new THREE.Vector3(15,22,0), [75,10]);
    rect.moveTo (63,-22)
	rect.rotateTo (Math.PI/2)
	var rect1 = new Rect(new THREE.Vector3(15,22,0), [15,10]);
	rect1.moveTo (-11, 41.5)
	rect1.rotateTo (Math.PI/4)
	var rect2 = new Rect(new THREE.Vector3(15,22,0), [150,10]);
	rect2.moveTo (-7, -64.5)
	var rect3 = new Rect(new THREE.Vector3(15,22,0), [75,10]);
	rect3.moveTo (-77, -22)
	rect3.rotateTo (Math.PI/2)
	var rect4 = new Rect(new THREE.Vector3(15,22,0), [45,10]);
	rect4.moveTo (-7, -37)
	rect4.rotateTo (Math.PI/2)
	var rect5 = new Rect(new THREE.Vector3(15,22,0), [75,10]);
	rect5.moveTo (30.5, 20)
	
	objects = [rect,rect1,rect2,rect3,rect4,rect5]
	
	var ccrect = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","1");
	ccrect.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/PxBLi7K.jpg");
	ccrect.moveTo (-135,20)
	objects.push(ccrect)
	cube.push(ccrect)
	
	var ccrect2 = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","2",1.2);
	ccrect2.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/b8QU98N.png");
	ccrect2.moveTo (-135,50)
	objects.push(ccrect2)
	cube.push(ccrect2)
	
	var finishss = new ggrect(new THREE.Vector3(15,22,0), [10,7.5]);
	finishss.moveTo (40,-56)
	objects.push(finishss)
	
	pickables = [finishss.obj,ccrect.obj,ccrect2.obj,rect.obj,rect1.obj,rect2.obj,rect3.obj,rect4.obj,rect5.obj];
	
	for(let y = 0 ; y < cube.length;y++){
		angle[y] = Math.PI/6;
	}
    ////////////
	////////////
	
}
function level1ballmake(){
	var ball0 = new Ball(new THREE.Vector3(),5);
    ball0.moveTo (-15,52)
	
	balls = [ball0];
	console.log(balls)
	
	objects.push(ball0)
}
function level2make(){
	countlevel=2;
	ans=0;
	var rect = new Rect(new THREE.Vector3(15,22,0), [15,10]);
    rect.moveTo (95,50)
	
	var rect1 = new Rect(new THREE.Vector3(15,22,0), [15,10]);
    rect1.moveTo (82.5,62.5)
	rect1.rotateTo (Math.PI/2)
	
	objects = [rect,rect1]
////////////////////////////////////////////////////////////
	var ccrect = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","1");
	ccrect.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/PxBLi7K.jpg");
	ccrect.moveTo (-200,50)
	objects.push(ccrect)
	cube.push(ccrect)
		
  
	var ccrect1 = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","2");
	ccrect1.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/PxBLi7K.jpg");
	ccrect1.moveTo (-200,35)
	objects.push(ccrect1)
	cube.push(ccrect1)
	
	
	var ccrect3 = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","3",1.2);
	ccrect3.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/b8QU98N.png");
	ccrect3.moveTo (-200,5)
	objects.push(ccrect3)
	cube.push(ccrect3)
	
	var ccrect4 = new Rect(new THREE.Vector3(15,22,0), [15,10],"myccrect","4",1.2);
	ccrect4.mesh.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/b8QU98N.png");
	ccrect4.moveTo (-200,-10)
	objects.push(ccrect4)
	cube.push(ccrect4)
	
	

  
	var finishss = new ggrect(new THREE.Vector3(15,22,0), [10,7.5]);
	finishss.moveTo (95,58)
	objects.push(finishss)
	
	console.log(finishss)
	
	pickables = [finishss.obj,ccrect.obj,ccrect1.obj,ccrect3.obj,ccrect4.obj];
	
	for(let y = 0 ; y < cube.length;y++){
		angle[y] = Math.PI/6;
	}
////////////////////////////////////////////////////////////
}
function level2ballmake(){
	/*var ball0 = new Ball(new THREE.Vector3(),5);
    ball0.moveTo (-90,62)*/
 	
	var ball1 = new Ballb(new THREE.Vector3(),5,3);
 	ball1.moveTo (-155,100)
	balls = [/*ball0,*/ball1]
	/*objects.push(ball0)*/
	objects.push(ball1)
}

function onWindowResize() {
  whRatio = window.innerWidth/window.innerHeight;
	halfH = 140;
  halfW = halfH*whRatio
	
  camera.left = -halfW; camera.right = halfW;
  camera.top = halfH; camera.bottom = -halfH;
  camera.updateProjectionMatrix();
	
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function onDocumentMouseDown(event) {
  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  // find intersections
  raycaster.setFromCamera(mouse, camera); 
  var intersects = raycaster.intersectObjects(pickables,true);
  
  if (intersects.length > 0) {	
	console.log(intersects)
	//console.log(cube[2].number);
	if(isShiftDown){
		console.log('132')
		if (intersects[0].object.number === 0 ) {
			//console.log(intersects[0]);
			//console.log(intersects[0].object.number);
		} 
		else{
			let picked = intersects[0].object.number;
			console.log(picked);
			var move = intersects[0].point.clone();
			if(picked > 0){
					var smallangle;
					movetest = picked-1;
					smallangle = angle[movetest];
					angle[movetest] += Math.PI/6
					console.log(smallangle)
					cube[movetest].rotateTo(smallangle)
					pickables.remove
			}
		}
	
	}
	else{
		if (intersects[0].object.number === 0 ) {
			//console.log(intersects[0]);
			//console.log(intersects[0].object.number);
		} 
		
		else if(intersects[0].object.number === -1){
			clickplay();
			start = !start;
			if(start){
			addf = false
			cilck1.material.map = THREE.ImageUtils.loadTexture("strts/pause.png");
			}
			else {
			cilck1.material.map = THREE.ImageUtils.loadTexture("strts/start.png");
			}
			
		}
		else if(intersects[0].object.number === -2){
			clickplay();
			console.log("fggfgfg")
			smallRE(levelnum);
			start = false
			cilck1.material.map = THREE.ImageUtils.loadTexture("strts/start.png");
		}
		else if(intersects[0].object.number === -3){
			clickplay();
			bigRE(levelnum);
			start = false
			cilck1.material.map = THREE.ImageUtils.loadTexture("strts/start.png");
		}
		else if(intersects[0].object.number === -4){
			clickplay();
			//scene.remove(bigcube)
			//console.log(pickables)
			refinish(levelnum)
			/*scene.remove.apply(scene, scene.children);
			init();*/
		}
		else if(intersects[0].object.number === -5){
			clickplay();
			console.log("fggfgfg")
			levelnum++;
			buildlevel(levelnum);
		}
		else if(intersects[0].object.number === -6){//問號功能
			clickplay();
			console.log("???");
			start = false;
			cilck1.material.map = THREE.ImageUtils.loadTexture("strts/start.png");
			//levelnum++;
			//buildlevel(levelnum);
			lock = !lock;			
			if(lock){
			document.getElementById("blocker").style.opacity= "0";
			document.getElementById("info").style.opacity= "0";
			lo1.position.set(500,500,0);
			lo2.position.set(500,500,0);
			lo3.position.set(500,500,0);
			lo4.position.set(500,500,0);
			lo5.position.set(500,500,0);
			}else{
			document.getElementById("blocker").style.opacity= "1";
			document.getElementById("info").style.opacity= "1";
			lo1.position.set(-50,89,0);
			lo2.position.set(-50,69.5,0);
			lo3.position.set(-50,50.5,0);
			lo4.position.set(-50,31.5,0);
			lo5.position.set(-50,13.5,0);
			}
		}
		else if(intersects[0].object.number === -7){//驚嘆提示
			clickplay();
			console.log("!!!")
			ans++;
			/////////提示出現 Math.PI/6 
			if(ans === 2 && countlevel=== 1){
				brickfa11.position.set (-60,-7,10);
				brickfa11.rotation.z = Math.PI/3
				console.log("ans2");
			}
			
			if(ans === 1 && countlevel=== 1){
				brickfa12.position.set (-46,-32,10);
				console.log("ans1");
			}
			
			if(ans === 1 && countlevel=== 2){
				brickfa21.position.set (-165,57.5,10);
				brickfa21.rotation.z = -Math.PI/6
				console.log("ans1");
			}
			if(ans === 2 && countlevel=== 2){
				brickfa22.position.set (-82.5,30,10);
				console.log("ans2");
			}
			if(ans === 3 && countlevel=== 2){
				brickfa23.position.set (30,45,10);
				console.log("ans3");
			}
			if(ans === 4 && countlevel=== 2){
				brickfa24.position.set (120,82.5,10);
				brickfa24.rotation.z = Math.PI/2
				console.log("ans4");
			}
			////////////
			//levelnum++;
			//buildlevel(levelnum);
			
		}
		else if(intersects[0].object.number === -8){//背景音開關
			clickplay();
			console.log("bbbgm")
			bgms = !bgms;
			if(bgms){
			cilck6.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/P4CP2NK.jpg");
			soundtrack.play();
			}
			else {
			cilck6.material.map = THREE.ImageUtils.loadTexture("https://i.imgur.com/OaKK32e.jpg");
			soundtrack.pause();
			}
			
		}
		else{
			let picked = intersects[0].object.number;
			
			console.log(picked);
			var move = intersects[0].point.clone();
			if(picked > 0){
				addf = !addf;
				if(addf == true){
					movetest = picked-1;
					console.log(cube[movetest])
					console.log(addf)
					console.log(move)
				}
				else{
					addf = false;
					console.log(addf)
					console.log(cube[movetest])
					console.log(move)
					cube[movetest].moveTo(move.x,move.y)
				}
			}
		}
	}
  }
}
function onDocumentMouseMove(event) {
  event.preventDefault();
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	
	var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
	raycaster.setFromCamera(mouse, camera);
	
	var intersects1 = raycaster.intersectObjects(pickables,true);
	if (intersects1.length > 0) {
		var move = intersects1[0].point.clone();
		if(addf == true ){
		console.log(movetest)
			cube[movetest].obj.position.copy (move);
		}
  }
}
function onDocumentKeyDown( event ) {
				switch ( event.keyCode ) {
					case 16: isShiftDown = true; break;
				}
			}
			
function onDocumentKeyUp( event ) {
				switch ( event.keyCode ) {
					case 16: isShiftDown = false; break;
				}
			}
function animate() {
	// apply gravity force to all balls
if(start == true){
  for (let i = 0; i < balls.length; i++)
  	balls[i].force.set (0,-10,0)
  for (let i = 0; i < balls.length; i++)
  	balls[i].update(0.1)
}
///////////////
    
////////////////////////
collision();
  //stats.update();
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script><canvas width="995" height="722" style="width: 995px; height: 722px;"></canvas>

</body></html>